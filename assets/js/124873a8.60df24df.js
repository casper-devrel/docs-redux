"use strict";(self.webpackChunkcspr_docs=self.webpackChunkcspr_docs||[]).push([[7795],{39026:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=n(74848),r=n(28453);const i={title:"Addressable Entity in Casper 2.0",description:"An introduction to the Addressable Entity concept.",slug:"addressable-entity",date:"2024-07-17T18:00",authors:["sczembor","melpadden"],tags:["condor"],hide_table_of_contents:!1},a="AddressableEntity in Casper 2.0",o={permalink:"/docs-redux/blog/addressable-entity",source:"@site/blog/2024-07-17-addressable-entity.md",title:"Addressable Entity in Casper 2.0",description:"An introduction to the Addressable Entity concept.",date:"2024-07-17T18:00:00.000Z",tags:[{inline:!1,label:"Condor",permalink:"/docs-redux/blog/tags/condor",description:"Blog posts related to the Condor upgrade"}],readingTime:3.665,hasTruncateMarker:!0,authors:[{name:"Stanislaw Czembor",page:{permalink:"/docs-redux/blog/authors/sczembor"},title:"Developer Advocate for Casper Association",url:"https://github.com/sczembor",permalink:"/sczembor",imageURL:"https://github.com/sczembor.png",key:"sczembor"},{name:"Mel Padden",page:{permalink:"/docs-redux/blog/authors/melpadden"},title:"Head of Developer Relations for Casper Association",url:"https://github.com/melpadden",socials:{x:"https://x.com/mel_casper"},permalink:"/melpadden",imageURL:"https://github.com/melpadden.png",key:"melpadden"}],frontMatter:{title:"Addressable Entity in Casper 2.0",description:"An introduction to the Addressable Entity concept.",slug:"addressable-entity",date:"2024-07-17T18:00",authors:["sczembor","melpadden"],tags:["condor"],hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"Casper Docs Redux!",permalink:"/docs-redux/blog/welcome-docs-redux"},nextItem:{title:"Fee Elimination in Condor",permalink:"/docs-redux/blog/condor-fee-elimination"}},c={authorsImageUrls:[void 0,void 0]},d=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"The inner workings of AddressableEntity",id:"the-inner-workings-of-addressableentity",level:2},{value:"Obtaining and converting Keys",id:"obtaining-and-converting-keys",level:2},{value:"Creating AddressableEntity Keys",id:"creating-addressableentity-keys",level:3},{value:"Extracting AccountHash or ContractHash from a Key",id:"extracting-accounthash-or-contracthash-from-a-key",level:3},{value:"The Address Merge in Condor",id:"the-address-merge-in-condor",level:2}];function l(e){const t={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Casper 2.0 introduces significant changes in the representation and management of accounts and smart contracts, through the introduction of the ",(0,s.jsx)(t.code,{children:"AddressableEntity"})," type. This new structure replaces the separate ",(0,s.jsx)(t.code,{children:"AccountHash"})," and ",(0,s.jsx)(t.code,{children:"ContractHash"})," used in Casper 1.x, bringing a unified approach to interact with entities on the network. Contracts can now hold and manage funds directly through associated purses, similar to user accounts. They can also manage their own keys, enabling more sophisticated access control."]}),"\n",(0,s.jsxs)(t.p,{children:["In this article, we'll dive into the details of ",(0,s.jsx)(t.code,{children:"AddressableEntity"}),", exploring its structure and functionalities."]}),"\n",(0,s.jsx)(t.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"AddressableEntity"})}),"\n",(0,s.jsxs)(t.p,{children:["At its core, an ",(0,s.jsx)(t.code,{children:"AddressableEntity"})," is a versatile data structure that represents both accounts and smart contracts within the Casper global state. It encapsulates all the necessary information for identifying and managing these entities. An ",(0,s.jsx)(t.code,{children:"AddressableEntity"})," provides a unified interface for various operations, including authorization, access control, and execution of functions."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"EntityAddr"})}),"\n",(0,s.jsxs)(t.p,{children:["An ",(0,s.jsx)(t.code,{children:"EntityAddr"})," serves as the address for an ",(0,s.jsx)(t.code,{children:"AddressableEntity"}),". It not only encodes the unique identifier (hash) of the entity but also its type. There are three distinct variants of ",(0,s.jsx)(t.code,{children:"EntityAddr"}),":"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"System:"})," Used for built-in, native contracts crucial for the blockchain's operation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Account:"}),"  Represents a user's account."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"SmartContract:"})," Represents a user-deployed smart contract."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"AddressableEntityHash"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"AddressableEntityHash"})," is a newtype wrapper around a 32-byte hash (",(0,s.jsx)(t.code,{children:"HashAddr"}),"). This hash functions as a unique identifier for the ",(0,s.jsx)(t.code,{children:"AddressableEntity"}),", typically derived from either the account's public key or the smart contract's hash using hashing algorithm."]}),"\n",(0,s.jsx)(t.h2,{id:"the-inner-workings-of-addressableentity",children:"The inner workings of AddressableEntity"}),"\n",(0,s.jsxs)(t.p,{children:["Let's dive into the critical components within an ",(0,s.jsx)(t.code,{children:"AddressableEntity"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"protocol_version"})," (ProtocolVersion):"]}),"  This field indicates the protocol version that the entity is compatible with. It ensures backward compatibility and allows for smooth upgrades as the Casper network evolves."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"entity_kind"})," (EntityKind):"]})," As mentioned earlier, this enum determines the type of entity \u2013 System, Account, or SmartContract."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"associated_keys"})," (AssociatedKeys):"]})," This data structure stores a map of public keys authorized to interact with the entity. Each key is associated with a weight that represents its voting power in decision-making processes within the entity."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"action_thresholds"})," (ActionThresholds):"]})," These thresholds define the minimum combined weight of associated keys required to authorize specific actions. The three main action types are ",(0,s.jsx)(t.code,{children:"deployment"}),", ",(0,s.jsx)(t.code,{children:"key_management"}),", and ",(0,s.jsx)(t.code,{children:"upgrade_management"}),". Each action type has its own weight threshold, allowing for fine-grained control over permissions."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"entry_points"})," (EntryPoints):"]})," This component is relevant only for smart contracts. It defines the functions (entry points) that external actors can call on the contract, along with their parameters, return types, and access permissions."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"obtaining-and-converting-keys",children:"Obtaining and converting Keys"}),"\n",(0,s.jsxs)(t.p,{children:["In Casper 2.0, developers will primarily work with ",(0,s.jsx)(t.code,{children:"Key::AddressableEntity"})," when referring to accounts and smart contracts. Here's how you can create them and convert between different key formats:"]}),"\n",(0,s.jsx)(t.h3,{id:"creating-addressableentity-keys",children:"Creating AddressableEntity Keys"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"From Account Hash:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let addressable_entity_key = Key::AddressableEntity(EntityAddr::Account(account_hash)); \n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"From Smart Contract Hash:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let addressable_entity_key = Key::AddressableEntity(EntityAddr::SmartContract(contract_hash));\n"})}),"\n",(0,s.jsx)(t.h3,{id:"extracting-accounthash-or-contracthash-from-a-key",children:"Extracting AccountHash or ContractHash from a Key"}),"\n",(0,s.jsxs)(t.p,{children:["You can extract the ",(0,s.jsx)(t.code,{children:"AccountHash"})," or ",(0,s.jsx)(t.code,{children:"ContractHash"})," from a ",(0,s.jsx)(t.code,{children:"Key::AddressableEntity"})," using pattern matching:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'//For Accounts\nlet account_hash = match addressable_entity_key {\n    Key::AddressableEntity(EntityAddr::Account(hash)) => hash,\n    _ => panic!("Not an account key"), \n};\n//For Contracts\nlet contract_hash = match addressable_entity_key {\n    Key::AddressableEntity(EntityAddr::SmartContract(hash)) => hash,\n    _ => panic!("Not a contract key"), \n};\n'})}),"\n",(0,s.jsx)(t.h2,{id:"the-address-merge-in-condor",children:"The Address Merge in Condor"}),"\n",(0,s.jsx)(t.p,{children:'The "Address Merge" in the Condor upgrade of Casper is a foundational shift, impacting how accounts and smart contracts are identified and interacted with.'}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Global State Transformation:"})}),"\n",(0,s.jsxs)(t.p,{children:["Post-Condor, all accounts and smart contract addresses residing within the global state will be automatically migrated to the ",(0,s.jsx)(t.code,{children:"AddressableEntity"})," structure. This means the network itself will recognize and handle these entities using the new format."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Smart Contract Compatibility Considerations:"})}),"\n",(0,s.jsxs)(t.p,{children:["While the global state automatically transitions to ",(0,s.jsx)(t.code,{children:"AddressableEntity"}),", existing contracts are expected to function without any modification."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Caller Identification:"}),"\nExisting host functions used to identify the caller within your contract will continue to work as before, ensuring no disruption to your contract's functionality. However, new host functions have been introduced that are specifically designed to work with the AddressableEntity format."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"External Contract Interaction:"})," Other contracts may have updated their interfaces to accept AddressableEntity arguments. Its worth to verify the argument types to avoid potential errors."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Note"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Upgrading a contract to a newer version may involve complexities, such as changes to the contract's addressable hash. These changes might require coordination with centralized and decentralized exchanges, as well as communication with your community to ensure a smooth transition."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);