"use strict";(self.webpackChunkcspr_docs=self.webpackChunkcspr_docs||[]).push([[3471],{98132:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});var i=s(74848),r=s(28453);const c={},a="Major Structures",t={id:"concepts/serialization/structures",title:"Major Structures",description:"Account",source:"@site/docs/concepts/serialization/structures.md",sourceDirName:"concepts/serialization",slug:"/concepts/serialization/structures",permalink:"/docs-redux/next/concepts/serialization/structures",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"sczembor",lastUpdatedAt:1724329928e3,frontMatter:{},sidebar:"concepts",previous:{title:"Primitives and Basic Serialization Rules",permalink:"/docs-redux/next/concepts/serialization/primitives"},next:{title:"Type Serialization",permalink:"/docs-redux/next/concepts/serialization/types"}},d={},l=[{value:"Account",id:"serialization-standard-account",level:2},{value:"AddressableEntity",id:"addressable-entity",level:2},{value:"Block",id:"serialization-standard-block",level:2},{value:"BlockHash",id:"block-hash",level:3},{value:"BlockHeader",id:"block-header",level:3},{value:"EraEndV1",id:"eraendV1",level:3},{value:"EraEndV2",id:"eraendV2",level:3},{value:"BlockBodyV1",id:"blockbodyV1",level:3},{value:"BlockBodyV2 {blockbodyv2}",id:"blockbodyv2-blockbodyv2",level:3},{value:"Contract",id:"contract",level:2},{value:"ContractPackageHash",id:"contractpackagehash",level:3},{value:"ContractWasmHash",id:"contractwasmhash",level:3},{value:"ContractHash",id:"contracthash",level:3},{value:"ContractPackageStatus",id:"contractpackagestatus",level:3},{value:"ContractVersion",id:"contractversion",level:3},{value:"ContractVersionKey",id:"contractversionkey",level:3},{value:"ContractWasm",id:"contractwasm",level:3},{value:"Message",id:"message",level:2},{value:"MessageAddr",id:"message-addr",level:3},{value:"MessageChecksum",id:"message-checksum",level:3},{value:"MessageLimits",id:"message-limits",level:3},{value:"MessagePayload",id:"message-payload",level:3},{value:"MessageTopicOperation",id:"message-topic-operation",level:3},{value:"TopicNameHash",id:"topic-name-hash",level:3},{value:"Transaction",id:"transaction",level:2},{value:"Deploy",id:"serialization-standard-deploy",level:3},{value:"DeployHash",id:"deploy-hash",level:3},{value:"DeployHeader",id:"deploy-header",level:3},{value:"Approval",id:"approval",level:3},{value:"ApprovalsHash",id:"approvals-hash",level:3},{value:"DeployInfo",id:"deployinfo",level:3},{value:"DeployConfig",id:"deployconfig",level:2},{value:"TransactionV1",id:"transactionV1",level:3},{value:"TransactionV1Hash",id:"transactionv1hash",level:3},{value:"TransactionV1Header",id:"transactionv1header",level:3},{value:"TransactionV1Body",id:"transactionv1body",level:3},{value:"TransactionRuntime",id:"transactionruntime",level:3},{value:"TransactionEntryPoint",id:"transactionentrypoint",level:3},{value:"TransactionConfig",id:"transactionconfig",level:3},{value:"TransactionV1Config",id:"transactionV1config",level:3},{value:"TransactionHash",id:"transactionhash",level:3},{value:"TransactionHeader",id:"transactionheader",level:3},{value:"TransactionId",id:"transactionid",level:3},{value:"TransactionScheduling",id:"transactionscheduling",level:3},{value:"TransactionInvocationTarget",id:"transactioninvocationtarget",level:3},{value:"TransactionTarget",id:"transactiontarget",level:3},{value:"TransactionWithExecutionInfo",id:"transaction-with-execution-info",level:3}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"major-structures",children:"Major Structures"})}),"\n",(0,i.jsx)(n.h2,{id:"serialization-standard-account",children:"Account"}),"\n",(0,i.jsxs)(n.p,{children:["An Account is a structure that represented a user on a legacy Casper network. Alongside the Condor protocol release, ",(0,i.jsx)(n.code,{children:"Accounts"})," were replaced with ",(0,i.jsx)(n.code,{children:"AddressableEntities"})," of the type ",(0,i.jsx)(n.code,{children:"Account"}),". The account structure consists of the following fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#account-hash",children:(0,i.jsx)(n.code,{children:"account_hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#namedkey",children:(0,i.jsx)(n.code,{children:"named_keys"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"main_purse"}),": The account's main purse ",(0,i.jsx)(n.code,{children:"URef"}),". You may find information on ",(0,i.jsx)(n.code,{children:"URef"})," serialization ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-uref",children:"here"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#associatedkey",children:(0,i.jsx)(n.code,{children:"associated_keys"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#account-action-thresholds",children:(0,i.jsx)(n.code,{children:"action_thresholds"})})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"addressable-entity",children:"AddressableEntity"}),"\n",(0,i.jsx)(n.p,{children:"An Addressable Entity is a structure that represents an entity on a Casper network. The addressable entity consists of the following fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#package-hash",children:(0,i.jsx)(n.code,{children:"package_hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#byte-code-hash",children:(0,i.jsx)(n.code,{children:"byte_code_hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entrypoints",children:(0,i.jsx)(n.code,{children:"entry_points"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#protocolversion",children:(0,i.jsx)(n.code,{children:"protocol_version"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"main_purse"}),": The entity's main purse ",(0,i.jsx)(n.code,{children:"URef"}),". You may find information on ",(0,i.jsx)(n.code,{children:"URef"})," serialization ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-uref",children:"here"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#associatedkey",children:(0,i.jsx)(n.code,{children:"associated_keys"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entity-action-thresholds",children:(0,i.jsx)(n.code,{children:"action_thresholds"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#message-topics",children:(0,i.jsx)(n.code,{children:"message_topics"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entity-kind",children:(0,i.jsx)(n.code,{children:"entity_kind"})})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"serialization-standard-block",children:"Block"}),"\n",(0,i.jsx)(n.p,{children:"A block is the core component of the Casper linear blockchain, used in two contexts:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A data structure containing a collection of transactions. Blocks form the primary structure of the blockchain."}),"\n",(0,i.jsx)(n.li,{children:"A message that is exchanged between nodes containing the data structure as explained in (1)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each block has a globally unique ID, achieved by hashing the contents of the block."}),"\n",(0,i.jsx)(n.p,{children:"Each block points to its parent. An exception is the first block, which has no parent."}),"\n",(0,i.jsx)(n.p,{children:"A block is structurally defined as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hash"}),": A hash over the header of the block."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"header"}),": The header of the block that contains information about the contents of the block with additional metadata."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"body"}),": The block's body contains the proposer of the block and hashes of deploys and transfers contained within it."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Further, a block may consist of one of the following types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Version1"}),": A legacy block created prior to the Condor upgrade."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Version2"}),": A modern block."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"block-hash",children:"BlockHash"}),"\n",(0,i.jsxs)(n.p,{children:["The block hash is a ",(0,i.jsx)(n.code,{children:"Digest"})," over the contents of the block Header. The ",(0,i.jsx)(n.code,{children:"BlockHash"})," serializes as the byte representation of the hash itself."]}),"\n",(0,i.jsx)(n.h3,{id:"block-header",children:"BlockHeader"}),"\n",(0,i.jsx)(n.p,{children:"The header portion of a block, structurally, is defined as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parent_hash"})," is the hash of the parent block. It serializes to the byte representation of the parent hash. The serialized buffer of the ",(0,i.jsx)(n.code,{children:"parent_hash"})," is 32 bytes long."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"state_root_hash"})," is the global state root hash produced by executing this block's body. It serializes to the byte representation of the ",(0,i.jsx)(n.code,{children:"state root hash"}),". The serialized buffer of the ",(0,i.jsx)(n.code,{children:"state_root_hash"})," is 32 bytes long."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"body_hash"})," the hash of the block body. It serializes to the byte representation of the body hash. The serialized buffer of the ",(0,i.jsx)(n.code,{children:"body_hash"})," is 32 bytes long."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"random_bit"})," is a boolean needed for initializing a future era. It is serialized as a single byte; true maps to 1, while false maps to 0."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"accumulated_seed"})," is a seed needed for initializing a future era. It serializes to the byte representation of the parent Hash. The serialized buffer of the ",(0,i.jsx)(n.code,{children:"accumulated_hash"})," is 32 bytes long."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"era_end"})," contains equivocation and reward information to be included in the terminal finalized block. It is an optional field. Thus if the field is set as ",(0,i.jsx)(n.code,{children:"None"}),", it serializes to ",(0,i.jsx)(n.em,{children:"0"}),". The serialization of the other case is described in the EraEnd."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timestamp"})," The timestamp from when the block was proposed. It serializes as a single ",(0,i.jsx)(n.code,{children:"u64"})," value. The serialization of a ",(0,i.jsx)(n.code,{children:"u64"})," value is described in the CLValues section."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"era_id"})," Era ID in which this block was created. It serializes as a single ",(0,i.jsx)(n.code,{children:"u64"})," value."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"height"})," The height of this block, i.e., the number of ancestors. It serializes as a single ",(0,i.jsx)(n.code,{children:"u64"})," value."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"protocol_version"})," The version of the Casper network when this block was proposed. It is 3-element tuple containing ",(0,i.jsx)(n.code,{children:"u32"})," values. It serializes as a buffer containing the three ",(0,i.jsx)(n.code,{children:"u32"})," serialized values. Refer to the CLValues section on how ",(0,i.jsx)(n.code,{children:"u32"})," values are serialized."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.code,{children:"BlockHeaderV1"})," and ",(0,i.jsx)(n.code,{children:"BlockHeaderV2"})," serialize in the same way."]}),"\n",(0,i.jsx)(n.h3,{id:"eraendV1",children:"EraEndV1"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EraEndV1"})," as represented within the block header, is a struct containing two fields."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"era_report"}),": The first field is termed as ",(0,i.jsx)(n.code,{children:"EraReport"})," and contains information about equivocators and rewards for an era."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"next_era_validator_weights"}),": The second field is map for the validators and their weights for the era to follow."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EraReport"})," itself contains two fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"equivocators"}),": A vector of ",(0,i.jsx)(n.code,{children:"PublicKey"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rewards"}),": A Binary Tree Map of ",(0,i.jsx)(n.code,{children:"PublicKey"})," and ",(0,i.jsx)(n.code,{children:"u64"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"inactive_validators"}),": A vector of ",(0,i.jsx)(n.code,{children:"PublicKey"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When serializing an EraReport, the buffer is first filled with the individual serialization of the PublicKey contained within the vector."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If the ",(0,i.jsx)(n.code,{children:"PublicKey"})," is an ",(0,i.jsx)(n.code,{children:"Ed25519"})," key, the first byte within the buffer is a ",(0,i.jsx)(n.code,{children:"1"})," followed by the individual bytes of the serialized key."]}),"\n",(0,i.jsxs)(n.li,{children:["If the ",(0,i.jsx)(n.code,{children:"PublicKey"})," is an ",(0,i.jsx)(n.code,{children:"Secp256k1"})," key, the first byte within the buffer is a ",(0,i.jsx)(n.code,{children:"2"})," followed by the individual bytes of the serialized key."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When serializing the overarching struct of ",(0,i.jsx)(n.code,{children:"EraEndV1"}),", we first allocate a buffer, which contains the serialized representation of the ",(0,i.jsx)(n.code,{children:"EraReport"})," as described above, followed by the serialized BTreeMap."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"EraEndV1"})," is an optional field. Thus the above scheme only applies if there is an ",(0,i.jsx)(n.code,{children:"EraEndV1"}),"; if there is no era end, the field simply serializes to ",(0,i.jsx)(n.em,{children:"0"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"eraendV2",children:"EraEndV2"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EraEndV1"})," as represented within the block header, is a struct containing four fields."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"equivocators"}),": A vector of ",(0,i.jsx)(n.code,{children:"PublicKey"})," listing equivocators for the era."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"inactive_validators"}),": A list of inactive validators for the era."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"next_era_validator_weights"}),": A map of validators and their weights for the era to follow."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rewards"}),": A Binary Tree Map of ",(0,i.jsx)(n.code,{children:"PublicKey"})," and ",(0,i.jsx)(n.code,{children:"u64"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"next_era_gas_price"}),": The next era's gas price as a ",(0,i.jsx)(n.code,{children:"u8"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"EraEndV2"})," is an optional field. Thus the above scheme only applies if there is an ",(0,i.jsx)(n.code,{children:"EraEndV2"}),"; if there is no era end, the field simply serializes to ",(0,i.jsx)(n.em,{children:"0"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"blockbodyV1",children:"BlockBodyV1"}),"\n",(0,i.jsx)(n.p,{children:"The body portion of a block, prior to the Condor upgrade, is structurally defined as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"proposer"}),": The PublicKey which proposed this block."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"deploy_hashes"}),": Is a vector of hex-encoded hashes identifying Deploys included in this block."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer_hashes"}),": Is a vector of hex-encoded hashes identifying Transfers included in this block."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When we serialize the ",(0,i.jsx)(n.code,{children:"BlockBodyV1"}),", we create a buffer that contains the serialized representations of the individual fields present within the block."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"proposer"})," serializes to the byte representation of the ",(0,i.jsx)(n.code,{children:"PublicKey"}),". If the ",(0,i.jsx)(n.code,{children:"PublicKey"})," is an ",(0,i.jsx)(n.code,{children:"Ed25519"})," key, then the first byte within the serialized buffer is 1 followed by the bytes of the key itself; else, in the case of ",(0,i.jsx)(n.code,{children:"Secp256k1"}),", the first byte is 2."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"deploy_hashes"})," serializes to the byte representation of all the deploy_hashes within the block header. Its length is ",(0,i.jsx)(n.code,{children:"32 * n"}),", where n denotes the number of deploy hashes present within the body."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer_hashes"})," serializes to the byte representation of all the deploy_hashes within the block header. Its length is ",(0,i.jsx)(n.code,{children:"32 * n"}),", where n denotes the number of transfers present within the body."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"blockbodyv2-blockbodyv2",children:"BlockBodyV2 {blockbodyv2}"}),"\n",(0,i.jsx)(n.p,{children:"A modern block is structurally defined as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"#transaction",children:(0,i.jsx)(n.code,{children:"transactions"})}),": Is a ",(0,i.jsx)(n.code,{children:"BTreeMap"})," of transaction hashes and their given categories. It is serialized as a ",(0,i.jsx)(n.code,{children:"BTreeMap"})," where the first 4 bytes represent a ",(0,i.jsx)(n.code,{children:"u32"})," value describing the number of values held within. The remainder consists of a repeating pattern of transaction categories as a ",(0,i.jsx)(n.code,{children:"u8"})," value and then the associated ",(0,i.jsx)(n.code,{children:"TransactionHash"})," the category tag describes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#rewarded-signatures",children:(0,i.jsx)(n.code,{children:"rewarded_signatures"})}),": A list of identifiers for finality signatures for a particular past block. It serializes as a vector of ",(0,i.jsx)(n.code,{children:"SingleBlockRewardedSignatures"})," which describes signatures for a single ancestor block. The first entry represents the signatures for the parent block, the second for the parent of the parent, and so on."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"contract",children:"Contract"}),"\n",(0,i.jsx)(n.p,{children:"A contract struct containing the following fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#contractpackagehash",children:(0,i.jsx)(n.code,{children:"contract_package_hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#contractwasmhash",children:(0,i.jsx)(n.code,{children:"contract_wasm_hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#namedkey",children:(0,i.jsx)(n.code,{children:"named_keys"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entrypoints",children:(0,i.jsx)(n.code,{children:"entry_points"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#protocolversion",children:(0,i.jsx)(n.code,{children:"protocol_version"})})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"contractpackagehash",children:"ContractPackageHash"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"blake2b"})," hash of a contract package. The contract package hash serializes as a 32-byte buffer containing the bytes of the contract package hash."]}),"\n",(0,i.jsx)(n.h3,{id:"contractwasmhash",children:"ContractWasmHash"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"blake2b"})," hash of a contract's Wasm. The contract's Wasm hash serializes as a 32-byte buffer containing the bytes of the contract's Wasm hash."]}),"\n",(0,i.jsx)(n.h3,{id:"contracthash",children:"ContractHash"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"blake2b"})," hash of a contract. The contract hash serializes as a 32-byte buffer containing the bytes of the contract hash."]}),"\n",(0,i.jsx)(n.h3,{id:"contractpackagestatus",children:"ContractPackageStatus"}),"\n",(0,i.jsxs)(n.p,{children:["The lock status of the contract package, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-boolean",children:(0,i.jsx)(n.code,{children:"boolean"})})," where ",(0,i.jsx)(n.code,{children:"true"})," indicates a locked contract and ",(0,i.jsx)(n.code,{children:"false"})," indicates an unlocked contract package."]}),"\n",(0,i.jsx)(n.h3,{id:"contractversion",children:"ContractVersion"}),"\n",(0,i.jsx)(n.p,{children:"The version of the contract."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"#contracthash",children:(0,i.jsx)(n.code,{children:"contract_hash"})}),": The contract hash of the contract."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"contract_version"}),": The version of the contract within the protocol major version. It serializes as a ",(0,i.jsxs)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:[(0,i.jsx)(n.code,{children:"u32"})," value"]}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"protocol_version_major"}),": The major element of the protocol version this contract is compatible with. It serializes as a ",(0,i.jsxs)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:[(0,i.jsx)(n.code,{children:"u32"})," value"]}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"contractversionkey",children:"ContractVersionKey"}),"\n",(0,i.jsxs)(n.p,{children:["The major element of ",(0,i.jsx)(n.code,{children:"ProtocolVersion"})," combined with ",(0,i.jsx)(n.code,{children:"Contract"})," Version serialized as two ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})})," values."]}),"\n",(0,i.jsx)(n.h3,{id:"contractwasm",children:"ContractWasm"}),"\n",(0,i.jsx)(n.p,{children:"A container for a contract's Wasm bytes, serialized as the byte representation of itself."}),"\n",(0,i.jsx)(n.h2,{id:"message",children:"Message"}),"\n",(0,i.jsxs)(n.p,{children:["A message emitted by an addressable entity during execution. The message ",(0,i.jsx)(n.code,{children:"struct"})," contains the following fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"entity_hash"}),": The identity of the entity that produced the message, serialized as an ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entity-addr",children:(0,i.jsx)(n.code,{children:"EntityAddr"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"message"}),": The payload of the message, serialized as a ",(0,i.jsx)(n.a,{href:"#message-payload",children:(0,i.jsx)(n.code,{children:"MessagePayload"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topic_name"}),": The name of the topic on which the message was emitted, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-string",children:(0,i.jsx)(n.code,{children:"String"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topic_name_hash"}),": The hash of the topic name, serialized as a ",(0,i.jsx)(n.a,{href:"#topic-name-hash",children:(0,i.jsx)(n.code,{children:"TopicNameHash"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topic_index"}),": The message index in the topic, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})})," value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"block_index"}),": The message index in the block, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})})," value."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"message-addr",children:"MessageAddr"}),"\n",(0,i.jsx)(n.p,{children:"A message topic address, a structure which consists of the following fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"entity_addr"}),": The entity address, serialized as an ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entity-addr",children:(0,i.jsx)(n.code,{children:"EntityAddr"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topic_name_hash"}),": The hash of the topic name, serialized as a ",(0,i.jsx)(n.a,{href:"#topic-name-hash",children:(0,i.jsx)(n.code,{children:"TopicNameHash"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"message_index"}),": The message index, serialized as an ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-option",children:(0,i.jsx)(n.code,{children:"Option"})})," of ",(0,i.jsx)(n.code,{children:"u32"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"message-checksum",children:"MessageChecksum"}),"\n",(0,i.jsxs)(n.p,{children:["A newtype wrapping an array which contains the raw bytes of the hash of the message emitted. It serializes as a ",(0,i.jsx)(n.code,{children:"CLType"})," ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," tag followed by a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-ByteArray",children:(0,i.jsx)(n.code,{children:"ByteArray"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"message-limits",children:"MessageLimits"}),"\n",(0,i.jsxs)(n.p,{children:["Configuration for message lists, serialized as three ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})})," values:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_topic_name_size"}),": Maximum size in bytes of a topic name string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_message_size"}),": Maximum message size in bytes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_topics_per_contract"}),": Maximum number of topics that a contract can register."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"message-payload",children:"MessagePayload"}),"\n",(0,i.jsxs)(n.p,{children:["The payload of a message emitted by an addressable entity during execution. It serializes as either a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 0 followed by a a serialized version of a human-readable ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-string",children:(0,i.jsx)(n.code,{children:"String"})}),", or as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 1 followed by serialized raw ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#bytes",children:(0,i.jsx)(n.code,{children:"Bytes"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"message-topic-operation",children:"MessageTopicOperation"}),"\n",(0,i.jsxs)(n.p,{children:["Operations that can be performed on message topics. Currently, serializes as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," of 0 representing the ",(0,i.jsx)(n.code,{children:"Add"})," function."]}),"\n",(0,i.jsx)(n.h3,{id:"topic-name-hash",children:"TopicNameHash"}),"\n",(0,i.jsxs)(n.p,{children:["The hash of the name of a message topic, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," describing the length of the string and the 32-byte serialized representation of the ",(0,i.jsx)(n.code,{children:"string"})," itself."]}),"\n",(0,i.jsx)(n.h2,{id:"transaction",children:"Transaction"}),"\n",(0,i.jsxs)(n.p,{children:["A versioned wrapper for a transaction or deploy. It serializes as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"0"})," followed by a ",(0,i.jsx)(n.a,{href:"#serialization-standard-deploy",children:(0,i.jsx)(n.code,{children:"Deploy"})})," or a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"1"})," followed by a ",(0,i.jsx)(n.a,{href:"#transactionV1",children:(0,i.jsx)(n.code,{children:"TransactionV1"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"serialization-standard-deploy",children:"Deploy"}),"\n",(0,i.jsx)(n.p,{children:"A deploy is a data structure containing a smart contract and the requester's signature(s). Additionally, the deploy header contains additional metadata about the deploy itself. A deploy is structurally defined as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hash"}),": The hash of the deploy header."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"header"}),": Contains metadata about the deploy. The structure of the header is detailed further in this document."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"payment"}),": The payment code for contained smart contract."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"session"}),": The stored contract itself."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"approvals"}),": A list of signatures."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"deploy-hash",children:"DeployHash"}),"\n",(0,i.jsx)(n.p,{children:"The deploy hash is a digest over the contents of the deploy header. The deploy hash serializes as the byte representation of the hash itself."}),"\n",(0,i.jsx)(n.h3,{id:"deploy-header",children:"DeployHeader"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"account"}),": A supported public key variant (currently either ",(0,i.jsx)(n.code,{children:"Ed25519"})," or ",(0,i.jsx)(n.code,{children:"Secp256k1"}),"). An ",(0,i.jsx)(n.code,{children:"Ed25519"})," key is serialized as a buffer of bytes, with the leading byte being ",(0,i.jsx)(n.code,{children:"1"})," for ",(0,i.jsx)(n.code,{children:"Ed25519"}),", with remainder of the buffer containing the byte representation of the signature. Correspondingly, a ",(0,i.jsx)(n.code,{children:"Secp256k1"})," key is serialized as a buffer of bytes, with the leading byte being ",(0,i.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timestamp"}),": A timestamp is a struct that is a unary tuple containing a ",(0,i.jsx)(n.code,{children:"u64"})," value. This value is a count of the milliseconds since the UNIX epoch. Thus the value ",(0,i.jsx)(n.code,{children:"1603994401469"})," serializes as ",(0,i.jsx)(n.code,{children:"0xbd3a847575010000"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ttl"}),": The ",(0,i.jsx)(n.strong,{children:"Time to live"})," is defined as the amount of time for which deploy is considered valid. The ",(0,i.jsx)(n.code,{children:"ttl"})," serializes in the same manner as the timestamp."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gas_price"}),": The gas is ",(0,i.jsx)(n.code,{children:"u64"})," value which is serialized as ",(0,i.jsx)(n.code,{children:"u64"})," CLValue discussed below."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"body_hash"}),": Body hash is a hash over the contents of the deploy body, which includes the payment, session, and approval fields. Its serialization is the byte representation of the hash itself."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dependencies"}),": Dependencies is a vector of deploy hashes referencing deploys that must execute before the current deploy can be executed. It serializes as a buffer containing the individual serialization of each DeployHash within the Vector."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chain_name"}),": Chain name is a human-readable string describing the name of the chain as detailed in the chainspec. It is serialized as a String CLValue described below."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"approval",children:"Approval"}),"\n",(0,i.jsx)(n.p,{children:"Approval contains two fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"signer"}),": The public key of the approvals signer. It serializes to the byte representation of the ",(0,i.jsx)(n.code,{children:"PublicKey"}),". If the ",(0,i.jsx)(n.code,{children:"PublicKey"})," is an ",(0,i.jsx)(n.code,{children:"Ed25519"})," key, then the first byte within the serialized buffer is 1 followed by the bytes of the key itself; else, in the case of ",(0,i.jsx)(n.code,{children:"Secp256k1"}),", the first byte is 2."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"signature"}),": The approval signature, which serializes as the byte representation of the ",(0,i.jsx)(n.code,{children:"Signature"}),". The first byte within the signature is 1 in the case of an ",(0,i.jsx)(n.code,{children:"Ed25519"})," signature or 2 in the case of ",(0,i.jsx)(n.code,{children:"Secp256k1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"approvals-hash",children:"ApprovalsHash"}),"\n",(0,i.jsxs)(n.p,{children:["The cryptographic hash of the bytesrepr-encoded set of approvals. It serializes as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#digest",children:(0,i.jsx)(n.code,{children:"digest"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"deployinfo",children:"DeployInfo"}),"\n",(0,i.jsx)(n.p,{children:"Information relating to a given deploy. The structure consists of the following fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"deploy_hash"}),": The hash of the relevant deploy, serialized as a byte representation of the hash itself."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"transfers"}),": Transfers performed by the deploy, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-list",children:(0,i.jsx)(n.code,{children:"List"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"from"}),": The account identifier of the creator of the deploy, serialized as an ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#account-hash",children:(0,i.jsx)(n.code,{children:"account_hash"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"source"}),": The source purse used for payment of the deploy, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-uref",children:(0,i.jsx)(n.code,{children:"URef"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gas"}),": The gas cost of executing the deploy, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"U512"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"deployconfig",children:"DeployConfig"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"struct"})," containing configuration values associated with ",(0,i.jsx)(n.code,{children:"deploys"}),". The structure contains the following fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_payment_cost"}),": The maximum amount any deploy can pay, serialized in ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#motes",children:(0,i.jsx)(n.code,{children:"Motes"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_dependencies"}),": The maximum time to live any deploy can specify, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"payment_args_max_length"}),": The maximum length in bytes of payment args per deploy, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"session_args_max_length"}),": The maximum length in bytes of session args per deploy, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionV1",children:"TransactionV1"}),"\n",(0,i.jsx)(n.p,{children:"A unit of work sent by a client to the network, which when executed can cause global state to be altered. It is structurally defined as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#transactionv1hash",children:(0,i.jsx)(n.code,{children:"TransactionV1Hash"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#transactionv1header",children:(0,i.jsx)(n.code,{children:"TransactionV1Header"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#transactionv1body",children:(0,i.jsx)(n.code,{children:"TransactionV1Body"})})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"approvals"}),": A list of signatures."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionv1hash",children:"TransactionV1Hash"}),"\n",(0,i.jsx)(n.p,{children:"The transaction hash is a digest over the contents of the transaction header. The transaction hash serializes as the byte representation of the hash itself."}),"\n",(0,i.jsx)(n.h3,{id:"transactionv1header",children:"TransactionV1Header"}),"\n",(0,i.jsx)(n.p,{children:"The header portion of a transaction, structurally, is defined as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chain_name"}),": Chain name is a human-readable string describing the name of the chain as detailed in the chainspec. It is serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-string",children:"String"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timestamp"}),": A timestamp is a struct that is a unary tuple containing a ",(0,i.jsx)(n.code,{children:"u64"})," value. This value is a count of the milliseconds since the UNIX epoch. Thus the value ",(0,i.jsx)(n.code,{children:"1603994401469"})," serializes as ",(0,i.jsx)(n.code,{children:"0xbd3a847575010000"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ttl"}),": The ",(0,i.jsx)(n.strong,{children:"Time to live"})," is defined as the amount of time for which the transaction is considered valid. The ",(0,i.jsx)(n.code,{children:"ttl"})," serializes in the same manner as the timestamp."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"body_hash"}),": Body hash is a hash over the contents of the ",(0,i.jsx)(n.a,{href:"#transactionv1body",children:"transaction body"}),". It serializes as the byte representation of the hash itself."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#pricingmode",children:(0,i.jsx)(n.code,{children:"pricing_mode"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#initiatoraddr",children:(0,i.jsx)(n.code,{children:"initator_addr"})})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionv1body",children:"TransactionV1Body"}),"\n",(0,i.jsxs)(n.p,{children:["The body of a ",(0,i.jsx)(n.code,{children:"TransactionV1"}),", consisting of the following:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#runtimeargs",children:(0,i.jsx)(n.code,{children:"args"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transactiontarget",children:(0,i.jsx)(n.code,{children:"target"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transactionentrypoint",children:(0,i.jsx)(n.code,{children:"entry_point"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transactionscheduling",children:(0,i.jsx)(n.code,{children:"scheduling"})})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionruntime",children:"TransactionRuntime"}),"\n",(0,i.jsxs)(n.p,{children:["The runtime used to execute a transaction, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})}),". Currently, only the ",(0,i.jsx)(n.code,{children:"VmCasperV1"})," is available, which serializes as a ",(0,i.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"transactionentrypoint",children:"TransactionEntryPoint"}),"\n",(0,i.jsxs)(n.p,{children:["An entry point of a transaction, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," value based on the type of entry point. The following table outlines the available types:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Tag"}),(0,i.jsx)(n.th,{children:"Entry Point"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"Custom"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Transfer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"Add_Bid"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"Withdraw_Bid"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:"Delegate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5"}),(0,i.jsx)(n.td,{children:"Undelegate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"6"}),(0,i.jsx)(n.td,{children:"Redelegate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"7"}),(0,i.jsx)(n.td,{children:"Activate_Bid"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"ChangePublicKey"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"9"}),(0,i.jsx)(n.td,{children:"Call"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"transactionconfig",children:"TransactionConfig"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"struct"})," containing configuration values associated with ",(0,i.jsx)(n.code,{children:"Transactions"}),". The structure contains the following fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_ttl"}),": The maximum time to live any transaction can specify, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#timediff",children:(0,i.jsx)(n.code,{children:"TimeDiff"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"block_max_approval_count"}),": The maximum number of approvals (signatures) allowed in a block across all transactions, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_block_size"}),": The maximum possible size in bytes of a block, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u32"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"block_gas_limit"}),": The maximum sum of payment across al transactions included in a block, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"native_transfer_minimum_motes"}),": The minimum token amount for a native transfer deploy or transaction, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_timestamp_leeway"}),": The maximum value to which a ",(0,i.jsx)(n.code,{children:"transaction_acceptor.timestamp_leeway"})," can be set in the ",(0,i.jsx)(n.em,{children:"config.toml"})," file."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"#deployconfig",children:(0,i.jsx)(n.code,{children:"deploy_config"})}),": Configuration values specific to Deploy transactions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"#transactionV1config",children:(0,i.jsx)(n.code,{children:"transaction_v1_config"})}),": Configuration values specific to V1 transactions."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionV1config",children:"TransactionV1Config"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"struct"})," containing configuration values associated with ",(0,i.jsx)(n.code,{children:"TransactionV1s"}),". The structure contains the following fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"native_mint_lane"}),": The lane configuration for the native mint interaction, serializing as a vector of ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})})," values."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"native_auction_lane"}),": The lane configuration for the native auction interaction, serializing as a vector of ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})})," values."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"wasm_lanes"}),": The lane configuration for the Wasm-based lanes, serializing as a nested vector of ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u64"})})," values."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactionhash",children:"TransactionHash"}),"\n",(0,i.jsxs)(n.p,{children:["A versioned wrapper for transaction hash or deploy hash. It serializes as either a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 0 followed by a ",(0,i.jsx)(n.a,{href:"#deploy-hash",children:(0,i.jsx)(n.code,{children:"DeployHash"})})," or a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 1 followed by a ",(0,i.jsx)(n.a,{href:"#transactionv1hash",children:(0,i.jsx)(n.code,{children:"TransactionV1Hash"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"transactionheader",children:"TransactionHeader"}),"\n",(0,i.jsxs)(n.p,{children:["A versioned wrapper for transaction header or deploy header. It serializes as either a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 0 followed by a ",(0,i.jsx)(n.a,{href:"#deploy-header",children:(0,i.jsx)(n.code,{children:"DeployHeader"})})," or a ",(0,i.jsx)(n.code,{children:"u8"})," tag of 1 followed by a ",(0,i.jsx)(n.a,{href:"#transactionv1header",children:(0,i.jsx)(n.code,{children:"TransactionV1Header"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"transactionid",children:"TransactionId"}),"\n",(0,i.jsxs)(n.p,{children:["The unique identifier of a ",(0,i.jsx)(n.code,{children:"Transaction"}),", serialized as its ",(0,i.jsx)(n.a,{href:"#transactionhash",children:(0,i.jsx)(n.code,{children:"TransactionHash"})})," and ",(0,i.jsx)(n.a,{href:"#approvals-hash",children:(0,i.jsx)(n.code,{children:"ApprovalsHash"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"transactionscheduling",children:"TransactionScheduling"}),"\n",(0,i.jsxs)(n.p,{children:["The scheduling mode of a transaction, serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," tag identifying the type:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Standard"})," serializes as a ",(0,i.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"FutureEra"})," serializes as a ",(0,i.jsx)(n.code,{children:"1"})," followed by a future ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#eraid",children:(0,i.jsx)(n.code,{children:"era_id"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"FutureTimestamp"})," serializes as a ",(0,i.jsx)(n.code,{children:"2"})," followed by a future ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#timestamp",children:(0,i.jsx)(n.code,{children:"timestamp"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactioninvocationtarget",children:"TransactionInvocationTarget"}),"\n",(0,i.jsxs)(n.p,{children:["The identifier of a ",(0,i.jsx)(n.code,{children:"stored"})," transaction target, serialized as one of the following:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"InvocableEntity"})," serializes as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"0"})," followed by the hex-encoded entity address serialized as the byte representation of itself."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"InvocableEntityAlias"})," serializes as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"1"})," followed by the alias serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-string",children:(0,i.jsx)(n.code,{children:"string"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Package"})," serializes as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"2"})," followed by the ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#package-hash",children:(0,i.jsx)(n.code,{children:"package hash"})})," and optionally the ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entityversionkey",children:(0,i.jsx)(n.code,{children:"entity_version"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PackageAlias"})," serializes as a ",(0,i.jsx)(n.code,{children:"u8"})," tag of ",(0,i.jsx)(n.code,{children:"3"})," followed by the alias serialized as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-string",children:(0,i.jsx)(n.code,{children:"string"})})," and optionally the ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/types#entityversionkey",children:(0,i.jsx)(n.code,{children:"entity_version"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transactiontarget",children:"TransactionTarget"}),"\n",(0,i.jsxs)(n.p,{children:["The execution target of a transaction, serializing as a ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-numeric",children:(0,i.jsx)(n.code,{children:"u8"})})," that identifies the type, followed by any additional data."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"native"})," serializes as a ",(0,i.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"stored"})," serializes as a ",(0,i.jsx)(n.code,{children:"1"})," followed by the ",(0,i.jsx)(n.a,{href:"#transactioninvocationtarget",children:(0,i.jsx)(n.code,{children:"id"})})," and ",(0,i.jsx)(n.a,{href:"#transactionruntime",children:(0,i.jsx)(n.code,{children:"runtime"})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"session"})," serializes as a ",(0,i.jsx)(n.code,{children:"2"})," followed by the ",(0,i.jsx)(n.a,{href:"#transactionsessionkind",children:(0,i.jsx)(n.code,{children:"kind"})}),", ",(0,i.jsx)(n.a,{href:"#payment--session",children:(0,i.jsx)(n.code,{children:"module_bytes"})})," and ",(0,i.jsx)(n.a,{href:"#transactionruntime",children:(0,i.jsx)(n.code,{children:"runtime"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transaction-with-execution-info",children:"TransactionWithExecutionInfo"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"struct"})," containing a",(0,i.jsx)(n.code,{children:"Transaction"})," with execution info. It serializes as a ",(0,i.jsx)(n.a,{href:"#transaction",children:(0,i.jsx)(n.code,{children:"Transaction"})})," followed by an ",(0,i.jsx)(n.a,{href:"/docs-redux/next/concepts/serialization/primitives#clvalue-option",children:(0,i.jsx)(n.code,{children:"Option"})})," of ",(0,i.jsx)(n.code,{children:"ExecutionInfo"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>t});var i=s(96540);const r={},c=i.createContext(r);function a(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);